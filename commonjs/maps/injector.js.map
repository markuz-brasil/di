{"version":3,"sources":["injector.js"],"names":[],"mappings":"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","file":"injector.js","sourcesContent":["/* jshint -W083 */\n\nimport {\n  annotate,\n  readAnnotations,\n  hasAnnotation,\n  Provide as ProvideAnnotation,\n  Factory as FactoryAnnotation,\n  TransientScope as TransientScopeAnnotation\n} from './annotations'\n\nimport { isFunction, toString } from './util'\nimport { createProviderFromFnOrClass } from './providers'\n\n\nfunction constructResolvingMessage(resolving, token) {\n  // If a token is passed in, add it into the resolving array.\n  // We need to check arguments.length because it can be null/undefined.\n  if (arguments.length > 1) {\n    resolving.push(token)\n  }\n\n  if (resolving.length > 1) {\n    return ` (${resolving.map(toString).join(' -> ')})`\n  }\n\n  return ''\n}\n\n\n// Injector encapsulate a life scope.\n// There is exactly one instance for given token in given injector.\n//\n// All the state is immutable, the only state changes is the cache. There is however no way to produce different instance under given token. In that sense it is immutable.\n//\n// Injector is responsible for:\n// - resolving tokens into\n//   - provider\n//   - value (cache/calling provider)\n// - dealing with isPromise\n// - dealing with isLazy\n// - loading different \"providers\" and modules\nexport class Injector {\n\n  constructor(modules = [], parentInjector = null, providers = new Map(), scopes = []) {\n    this._cache = new Map()\n    this._providers = providers\n    this._parent = parentInjector\n    this._scopes = scopes\n\n    this._loadModules(modules)\n\n  }\n\n\n  // Collect all registered providers that has given annotation.\n  // Including providers defined in parent injectors.\n  _collectProvidersWithAnnotation(annotationClass, collectedProviders) {\n    this._providers.forEach((provider, token) => {\n      if (!collectedProviders.has(token) && hasAnnotation(provider.provider, annotationClass)) {\n        collectedProviders.set(token, provider)\n      }\n    })\n\n    if (this._parent) {\n      this._parent._collectProvidersWithAnnotation(annotationClass, collectedProviders)\n    }\n  }\n\n\n  // Load modules/function/classes.\n  // This mutates `this._providers`, but it is only called during the constructor.\n  _loadModules(modules) {\n    for (var module of modules) {\n      // A single provider (class or function).\n      if (isFunction(module)) {\n        this._loadFnOrClass(module)\n        continue\n      }\n\n      throw new Error('Invalid module!')\n    }\n  }\n\n\n  // Load a function or class.\n  // This mutates `this._providers`, but it is only called during the constructor.\n  _loadFnOrClass(fnOrClass) {\n    // TODO(vojta): should we expose provider.token?\n    var annotations = readAnnotations(fnOrClass)\n    var token = annotations.provide.token || fnOrClass\n    var provider = createProviderFromFnOrClass(fnOrClass, annotations)\n\n    this._providers.set(token, provider)\n  }\n\n\n  // Returns true if there is any provider registered for given token.\n  // Including parent injectors.\n  _hasProviderFor(token) {\n    if (this._providers.has(token)) {\n      return true\n    }\n\n    if (this._parent) {\n      return this._parent._hasProviderFor(token)\n    }\n\n    return false\n  }\n\n  // Find the correct injector where the default provider should be instantiated and cached.\n  _instantiateDefaultProvider(provider, token, resolving, wantPromise, wantLazy) {\n    // In root injector, instantiate here.\n    if (!this._parent) {\n      this._providers.set(token, provider)\n      return this.get(token, resolving, wantPromise, wantLazy)\n    }\n\n    // Check if this injector forces new instance of this provider.\n    for (var ScopeClass of this._scopes) {\n      if (hasAnnotation(provider.provider, ScopeClass)) {\n        this._providers.set(token, provider)\n        return this.get(token, resolving, wantPromise, wantLazy)\n      }\n    }\n\n    // Otherwise ask parent injector.\n    return this._parent._instantiateDefaultProvider(provider, token, resolving, wantPromise, wantLazy)\n  }\n\n\n  // Return an instance for given token.\n  get(token, resolving = [], wantPromise = false, wantLazy = false) {\n    var resolvingMsg = ''\n    var provider\n    var instance\n    var injector = this\n\n    if (token === null || token === undefined) {\n      resolvingMsg = constructResolvingMessage(resolving, token)\n      throw new Error(`Invalid token \"${token}\" requested!${resolvingMsg}`)\n    }\n\n    // Special case, return itself.\n    if (token === Injector) {\n      if (wantPromise) {\n        return Promise.resolve(this)\n      }\n\n      return this\n    }\n\n    // TODO(vojta): optimize - no child injector for locals?\n    if (wantLazy) {\n      return function createLazyInstance() {\n        var lazyInjector = injector\n\n        if (arguments.length) {\n          var locals = []\n          var args = arguments\n\n          for (var i = 0; i < args.length; i += 2) {\n            locals.push((function(ii) {\n              var fn = function createLocalInstance() {\n                return args[ii + 1]\n              }\n\n              annotate(fn, new ProvideAnnotation(args[ii]))\n\n              return fn\n            })(i))\n          }\n\n          lazyInjector = injector.createChild(locals)\n        }\n\n        return lazyInjector.get(token, resolving, wantPromise, false)\n      }\n    }\n\n    // Check if there is a cached instance already.\n    if (this._cache.has(token)) {\n      instance = this._cache.get(token)\n      provider = this._providers.get(token)\n\n      if (provider.isPromise && !wantPromise) {\n        resolvingMsg = constructResolvingMessage(resolving, token)\n        throw new Error(`Cannot instantiate ${toString(token)} synchronously. It is provided as a promise!${resolvingMsg}`)\n      }\n\n      if (!provider.isPromise && wantPromise) {\n        return Promise.resolve(instance)\n      }\n\n      return instance\n    }\n\n    provider = this._providers.get(token)\n\n    // No provider defined (overridden), use the default provider (token).\n    if (!provider && isFunction(token) && !this._hasProviderFor(token)) {\n      provider = createProviderFromFnOrClass(token, readAnnotations(token))\n      return this._instantiateDefaultProvider(provider, token, resolving, wantPromise, wantLazy)\n    }\n\n    if (!provider) {\n      if (!this._parent) {\n        resolvingMsg = constructResolvingMessage(resolving, token)\n        throw new Error(`No provider for ${toString(token)}!${resolvingMsg}`)\n      }\n\n      return this._parent.get(token, resolving, wantPromise, wantLazy)\n    }\n\n    if (resolving.indexOf(token) !== -1) {\n      resolvingMsg = constructResolvingMessage(resolving, token)\n      throw new Error(`Cannot instantiate cyclic dependency!${resolvingMsg}`)\n    }\n\n    resolving.push(token)\n\n    // TODO(vojta): handle these cases:\n    // 1/\n    // - requested as promise (delayed)\n    // - requested again as promise (before the previous gets resolved) -> cache the promise\n    // 2/\n    // - requested as promise (delayed)\n    // - requested again sync (before the previous gets resolved)\n    // -> error, but let it go inside to throw where exactly is the async provider\n    var delayingInstantiation = wantPromise && provider.params.some((param) => !param.isPromise)\n    var args = provider.params.map((param) => {\n\n      if (delayingInstantiation) {\n        return this.get(param.token, resolving, true, param.isLazy)\n      }\n\n      return this.get(param.token, resolving, param.isPromise, param.isLazy)\n    })\n\n    // Delaying the instantiation - return a promise.\n    if (delayingInstantiation) {\n      var delayedResolving = resolving.slice() // clone\n\n      resolving.pop()\n\n      // Once all dependencies (promises) are resolved, instantiate.\n      return Promise.all(args).then(function(args) {\n        try {\n          instance = provider.create(args)\n        } catch (e) {\n          resolvingMsg = constructResolvingMessage(delayedResolving)\n          var originalMsg = 'ORIGINAL ERROR: ' + e.message\n          e.message = `Error during instantiation of ${toString(token)}!${resolvingMsg}\\n${originalMsg}`\n          throw e\n        }\n\n        if (!hasAnnotation(provider.provider, TransientScopeAnnotation)) {\n          injector._cache.set(token, instance)\n        }\n\n        // TODO(vojta): if a provider returns a promise (but is not declared as @ProvidePromise),\n        // here the value will get unwrapped (because it is returned from a promise callback) and\n        // the actual value will be injected. This is probably not desired behavior. Maybe we could\n        // get rid off the @ProvidePromise and just check the returned value, whether it is\n        // a promise or not.\n        return instance\n      })\n    }\n\n    try {\n      instance = provider.create(args)\n    } catch (e) {\n      resolvingMsg = constructResolvingMessage(resolving)\n      var originalMsg = 'ORIGINAL ERROR: ' + e.message\n      e.message = `Error during instantiation of ${toString(token)}!${resolvingMsg}\\n${originalMsg}`\n      throw e\n    }\n\n    if (!hasAnnotation(provider.provider, TransientScopeAnnotation)) {\n      this._cache.set(token, instance)\n    }\n\n    if (!wantPromise && provider.isPromise) {\n      resolvingMsg = constructResolvingMessage(resolving)\n\n      throw new Error(`Cannot instantiate ${toString(token)} synchronously. It is provided as a promise!${resolvingMsg}`)\n    }\n\n    if (wantPromise && !provider.isPromise) {\n      instance = Promise.resolve(instance)\n    }\n\n    resolving.pop()\n\n    return instance\n  }\n\n\n  getPromise(token) {\n    return this.get(token, [], true)\n  }\n\n\n  // Create a child injector, which encapsulate shorter life scope.\n  // It is possible to add additional providers and also force new instances of existing providers.\n  createChild(modules = [], forceNewInstancesOf = []) {\n    var forcedProviders = new Map()\n\n    // Always force new instance of TransientScope.\n    forceNewInstancesOf.push(TransientScopeAnnotation)\n\n    for (var annotation of forceNewInstancesOf) {\n      this._collectProvidersWithAnnotation(annotation, forcedProviders)\n    }\n\n    return new Injector(modules, this, forcedProviders, forceNewInstancesOf)\n  }\n}\n"],"sourceRoot":"/source/"}