{"version":3,"sources":["injector.js"],"names":[],"mappings":"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","file":"injector.js","sourcesContent":["/* jshint -W083 */\n\nimport {\n  annotate,\n  readAnnotations,\n  hasAnnotation,\n  Provide as ProvideAnnotation,\n  TransientScope as TransientScopeAnnotation\n} from './annotations';\n\nimport {isFunction, toString} from './util';\nimport {profileInjector} from './profiler';\nimport {createProviderFromFnOrClass} from './providers';\n\n\nfunction constructResolvingMessage(resolving, token) {\n  // If a token is passed in, add it into the resolving array.\n  // We need to check arguments.length because it can be null/undefined.\n  if (arguments.length > 1) {\n    resolving.push(token);\n  }\n\n  if (resolving.length > 1) {\n    return ` (${resolving.map(toString).join(' -> ')})`;\n  }\n\n  return '';\n}\n\n\n// Injector encapsulate a life scope.\n// There is exactly one instance for given token in given injector.\n//\n// All the state is immutable, the only state changes is the cache. There is however no way to produce different instance under given token. In that sense it is immutable.\n//\n// Injector is responsible for:\n// - resolving tokens into\n//   - provider\n//   - value (cache/calling provider)\n// - dealing with isPromise\n// - dealing with isLazy\n// - loading different \"providers\" and modules\nclass Injector {\n\n  constructor(modules = [], parentInjector = null, providers = new Map(), scopes = []) {\n    this._cache = new Map();\n    this._providers = providers;\n    this._parent = parentInjector;\n    this._scopes = scopes;\n\n    this._loadModules(modules);\n\n    profileInjector(this, Injector);\n  }\n\n\n  // Collect all registered providers that has given annotation.\n  // Including providers defined in parent injectors.\n  _collectProvidersWithAnnotation(annotationClass, collectedProviders) {\n    this._providers.forEach((provider, token) => {\n      if (!collectedProviders.has(token) && hasAnnotation(provider.provider, annotationClass)) {\n        collectedProviders.set(token, provider);\n      }\n    });\n\n    if (this._parent) {\n      this._parent._collectProvidersWithAnnotation(annotationClass, collectedProviders);\n    }\n  }\n\n\n  // Load modules/function/classes.\n  // This mutates `this._providers`, but it is only called during the constructor.\n  _loadModules(modules) {\n    for (var module of modules) {\n      // A single provider (class or function).\n      if (isFunction(module)) {\n        this._loadFnOrClass(module);\n        continue;\n      }\n\n      throw new Error('Invalid module!');\n    }\n  }\n\n\n  // Load a function or class.\n  // This mutates `this._providers`, but it is only called during the constructor.\n  _loadFnOrClass(fnOrClass) {\n    // TODO(vojta): should we expose provider.token?\n    var annotations = readAnnotations(fnOrClass);\n    var token = annotations.provide.token || fnOrClass;\n    var provider = createProviderFromFnOrClass(fnOrClass, annotations);\n\n    this._providers.set(token, provider);\n  }\n\n\n  // Returns true if there is any provider registered for given token.\n  // Including parent injectors.\n  _hasProviderFor(token) {\n    if (this._providers.has(token)) {\n      return true;\n    }\n\n    if (this._parent) {\n      return this._parent._hasProviderFor(token);\n    }\n\n    return false;\n  }\n\n  // Find the correct injector where the default provider should be instantiated and cached.\n  _instantiateDefaultProvider(provider, token, resolving, wantPromise, wantLazy) {\n    // In root injector, instantiate here.\n    if (!this._parent) {\n      this._providers.set(token, provider);\n      return this.get(token, resolving, wantPromise, wantLazy);\n    }\n\n    // Check if this injector forces new instance of this provider.\n    for (var ScopeClass of this._scopes) {\n      if (hasAnnotation(provider.provider, ScopeClass)) {\n        this._providers.set(token, provider);\n        return this.get(token, resolving, wantPromise, wantLazy);\n      }\n    }\n\n    // Otherwise ask parent injector.\n    return this._parent._instantiateDefaultProvider(provider, token, resolving, wantPromise, wantLazy);\n  }\n\n\n  // Return an instance for given token.\n  get(token, resolving = [], wantPromise = false, wantLazy = false) {\n    var resolvingMsg = '';\n    var provider;\n    var instance;\n    var injector = this;\n\n    if (token === null || token === undefined) {\n      resolvingMsg = constructResolvingMessage(resolving, token);\n      throw new Error(`Invalid token \"${token}\" requested!${resolvingMsg}`);\n    }\n\n    // Special case, return itself.\n    if (token === Injector) {\n      if (wantPromise) {\n        return Promise.resolve(this);\n      }\n\n      return this;\n    }\n\n    // TODO(vojta): optimize - no child injector for locals?\n    if (wantLazy) {\n      return function createLazyInstance() {\n        var lazyInjector = injector;\n\n        if (arguments.length) {\n          var locals = [];\n          var args = arguments;\n\n          for (var i = 0; i < args.length; i += 2) {\n            locals.push((function(ii) {\n              var fn = function createLocalInstance() {\n                return args[ii + 1];\n              };\n\n              annotate(fn, new ProvideAnnotation(args[ii]));\n\n              return fn;\n            })(i));\n          }\n\n          lazyInjector = injector.createChild(locals);\n        }\n\n        return lazyInjector.get(token, resolving, wantPromise, false);\n      };\n    }\n\n    // Check if there is a cached instance already.\n    if (this._cache.has(token)) {\n      instance = this._cache.get(token);\n      provider = this._providers.get(token);\n\n      if (provider.isPromise && !wantPromise) {\n        resolvingMsg = constructResolvingMessage(resolving, token);\n        throw new Error(`Cannot instantiate ${toString(token)} synchronously. It is provided as a promise!${resolvingMsg}`);\n      }\n\n      if (!provider.isPromise && wantPromise) {\n        return Promise.resolve(instance);\n      }\n\n      return instance;\n    }\n\n    provider = this._providers.get(token);\n\n    // No provider defined (overridden), use the default provider (token).\n    if (!provider && isFunction(token) && !this._hasProviderFor(token)) {\n      provider = createProviderFromFnOrClass(token, readAnnotations(token));\n      return this._instantiateDefaultProvider(provider, token, resolving, wantPromise, wantLazy);\n    }\n\n    if (!provider) {\n      if (!this._parent) {\n        resolvingMsg = constructResolvingMessage(resolving, token);\n        throw new Error(`No provider for ${toString(token)}!${resolvingMsg}`);\n      }\n\n      return this._parent.get(token, resolving, wantPromise, wantLazy);\n    }\n\n    if (resolving.indexOf(token) !== -1) {\n      resolvingMsg = constructResolvingMessage(resolving, token);\n      throw new Error(`Cannot instantiate cyclic dependency!${resolvingMsg}`);\n    }\n\n    resolving.push(token);\n\n    // TODO(vojta): handle these cases:\n    // 1/\n    // - requested as promise (delayed)\n    // - requested again as promise (before the previous gets resolved) -> cache the promise\n    // 2/\n    // - requested as promise (delayed)\n    // - requested again sync (before the previous gets resolved)\n    // -> error, but let it go inside to throw where exactly is the async provider\n    var delayingInstantiation = wantPromise && provider.params.some((param) => !param.isPromise);\n    var args = provider.params.map((param) => {\n\n      if (delayingInstantiation) {\n        return this.get(param.token, resolving, true, param.isLazy);\n      }\n\n      return this.get(param.token, resolving, param.isPromise, param.isLazy);\n    });\n\n    // Delaying the instantiation - return a promise.\n    if (delayingInstantiation) {\n      var delayedResolving = resolving.slice(); // clone\n\n      resolving.pop();\n\n      // Once all dependencies (promises) are resolved, instantiate.\n      return Promise.all(args).then(function(args) {\n        try {\n          instance = provider.create(args);\n        } catch (e) {\n          resolvingMsg = constructResolvingMessage(delayedResolving);\n          var originalMsg = 'ORIGINAL ERROR: ' + e.message;\n          e.message = `Error during instantiation of ${toString(token)}!${resolvingMsg}\\n${originalMsg}`;\n          throw e;\n        }\n\n        if (!hasAnnotation(provider.provider, TransientScopeAnnotation)) {\n          injector._cache.set(token, instance);\n        }\n\n        // TODO(vojta): if a provider returns a promise (but is not declared as @ProvidePromise),\n        // here the value will get unwrapped (because it is returned from a promise callback) and\n        // the actual value will be injected. This is probably not desired behavior. Maybe we could\n        // get rid off the @ProvidePromise and just check the returned value, whether it is\n        // a promise or not.\n        return instance;\n      });\n    }\n\n    try {\n      instance = provider.create(args);\n    } catch (e) {\n      resolvingMsg = constructResolvingMessage(resolving);\n      var originalMsg = 'ORIGINAL ERROR: ' + e.message;\n      e.message = `Error during instantiation of ${toString(token)}!${resolvingMsg}\\n${originalMsg}`;\n      throw e;\n    }\n\n    if (!hasAnnotation(provider.provider, TransientScopeAnnotation)) {\n      this._cache.set(token, instance);\n    }\n\n    if (!wantPromise && provider.isPromise) {\n      resolvingMsg = constructResolvingMessage(resolving);\n\n      throw new Error(`Cannot instantiate ${toString(token)} synchronously. It is provided as a promise!${resolvingMsg}`);\n    }\n\n    if (wantPromise && !provider.isPromise) {\n      instance = Promise.resolve(instance);\n    }\n\n    resolving.pop();\n\n    return instance;\n  }\n\n\n  getPromise(token) {\n    return this.get(token, [], true);\n  }\n\n\n  // Create a child injector, which encapsulate shorter life scope.\n  // It is possible to add additional providers and also force new instances of existing providers.\n  createChild(modules = [], forceNewInstancesOf = []) {\n    var forcedProviders = new Map();\n\n    // Always force new instance of TransientScope.\n    forceNewInstancesOf.push(TransientScopeAnnotation);\n\n    for (var annotation of forceNewInstancesOf) {\n      this._collectProvidersWithAnnotation(annotation, forcedProviders);\n    }\n\n    return new Injector(modules, this, forcedProviders, forceNewInstancesOf);\n  }\n}\n\n\nexport {Injector};\n"],"sourceRoot":"/source/"}